/* Homework Problem 8-26 */
/*Things to implement
 * 1. Built-in commands
 * 	  jobs
 * 	  bg 
 *    fg
 * 	  kill (will need to do it in lab)
 * 2. Way to maintain list of list of jobs (possibly linked list implementation)
 * 3. Handling of Ctrl+C(Ctrl+Z) signals
 * 4. Sending of SIGCONT signal by bg job
 * 5. Sending of SIGCONT signal by fg job
 * 6. Way to start/stop a process
 * 7. Way to restart a process
 * Pointer to solution
 * kill system call to send signal to jobs
 * receving signal with signal system call
 * SIGTSTP - to stop a running process
 * SIGCONT - to restart a process stoped by SIGSTOP
 * waitpid system call to get status of process (running/stoped) ref pg. 780
 * WIFSTOPPED(status) if process is stoped
 * WSTOPSIG(status) to find signal that stopped process
 */
#include "csapp.h"
#define MAXARGS   128
#define FG			0 /* Foreground process */
#define BG			1 /* Background process */
#define JOBID		0 /* Find process by job id */
#define PROCESSID	1 /* Find process by process num */
#define RUNNING		0 /* Process is running */
#define STOPPED		1 /* Process is stopped */
/* Process entry structure */
typedef struct process_entry
{
	unsigned int job_id;     /* Job ID to be generated by program */
	unsigned int process_id; /* Process ID returned by kernel */
	char run_status;	 	 /* Run status of process */
	char cmdline[MAXLINE];	 /* Command line string */
	struct process_entry *next;			 /* Pointer to next entry in linked list */
} process_entry_t;

/* Global variables */
unsigned int global_job_id; /* global variable to record number of job being generated */
process_entry_t *global_list; /* global list to keep track of number of jobs being run */ 
jmp_buf buf; /* Jump buffer used in setjmp and longjmp */
volatile sig_atomic_t global_pid;
volatile pid_t fg_process; /* for foreground process */
/* Function prototypes */
void eval(char *cmdline);
int parseline(char *buf, char **argv);
int builtin_command(char **argv);
/* self defined functions */
int add_job(pid_t pid, char *cmd_line); /* Function to add job to list */
void delete_jobs(pid_t pid); /* Function to delete job from list */
process_entry_t* find_job(int process, int type); /* Function to find job from global list */
int update_process(pid_t pid, char run_status); /* Function to update run status of a process */
void display_jobs(); /* Function to display jobs */
void do_bgfg(int fgbg, char *job_num); /* Function to process bg and fg command */

/* Handler for SIGCHLD signal */
void handler_sigchld(int sig)
{
	/* This handler is called when
	 * 1. Child is terminated
	 * 2. Child is stopped
	 * 3. Child is continued
	 */
	pid_t pid;
	/* check for terminating process */
	while ((global_pid = waitpid(-1, NULL, WNOHANG)) > 0) {
      delete_jobs(global_pid);
      if (fg_process > 0) {  
		fg_process = 0;
		siglongjmp(buf, 1);
	  }
	}
	
	/* check for stopped process */
	while ((pid = waitpid(-1, NULL, WNOHANG|WUNTRACED)) > 0) {
      if (!update_process(pid, STOPPED)) {
		printf("Unable to update run status of process: %d\n", pid);
		exit(0);
	  }
	  if (fg_process > 0) {  
		fg_process = 0;
		siglongjmp(buf, 1);
	  }
	}
	
	/* check for continued process */
	while ((global_pid = waitpid(-1, NULL, WNOHANG|WCONTINUED)) > 0) {
      if (!update_process(global_pid, RUNNING)) {
		printf("Unable to update run status of process: %d\n", pid);
		exit(0);
	  }
	}
}

/* Handler for SIGINT signal */
void handler_jobcontrol(int sig)
{
	//pid_t pid;
	//printf("Inside handler_jobcontrol\n");
	//printf("Recievied signal no: %d\n", sig);
	if (sig == SIGINT && fg_process > 0)
	{
		printf("Job %d terminated by signal: Interrupt\n", fg_process);
		kill(fg_process, SIGINT);
	}
	else if (sig == SIGTSTP && fg_process > 0)
	{
		printf("Job %d stopped by signal: Stopped\n", fg_process);
		kill(fg_process, SIGTSTP);
	}
	else
	{
		//printf("No process in foreground\n");
	}
}
/* Handler for SIGTSTP signal */


int main() 
{
    char cmdline[MAXLINE]; /* Command line */
    
    /* Initalize global variables */
    global_job_id = 0;
    global_list = NULL;
    fg_process = 0;
	
    if (!sigsetjmp(buf, 1)) {
        /*Install signal handlers */
        Signal(SIGINT, handler_jobcontrol);
        Signal(SIGCHLD, handler_sigchld);
        Signal(SIGTSTP, handler_jobcontrol);
    }
    while (1) {
      /* Read */
      printf("> ");                   
      Fgets(cmdline, MAXLINE, stdin); 
      if (feof(stdin))
        exit(0);
      /* Evaluate */
      eval(cmdline);
    } 
}
/* $end shellmain */
  
/* $begin eval */
/* eval - Evaluate a command line */
void eval(char *cmdline) 
{
    char *argv[MAXARGS]; /* Argument list execve() */
    char buf[MAXLINE];   /* Holds modified command line */
    int bg;              /* Should the job run in bg or fg? */
    pid_t pid;           /* Process id */
    sigset_t mask, prev_mask; /* Signal masks */
    
    strcpy(buf, cmdline);
    bg = parseline(buf, argv); 
    if (argv[0] == NULL)  
      return;   /* Ignore empty lines */

    if (!builtin_command(argv)) { 
        if ((pid = Fork()) == 0) {   /* Child runs user job */
            setpgid(0, 0);
            if (execve(argv[0], argv, environ) < 0) {
                printf("%s: Command not found.\n", argv[0]);
                exit(0);
            }
        }
        /* Parent process shellex */
        else { 
			
			Sigemptyset(&mask);
			Sigaddset(&mask, SIGCHLD);
			Sigprocmask(SIG_BLOCK, &mask, &prev_mask);
			if (!add_job(pid, cmdline)) {
				printf("Unable to add job to job list. Exiting....\n");
				exit(0);
			}
			/* Parent waits for foreground job to terminate */
			if (!bg) {
				fg_process = pid; /* Mark foreground process */
				global_pid = 0;
				while (!global_pid)
					sigsuspend(&prev_mask);
			}
			else
				printf("[%d] %d %s",global_job_id, pid, cmdline);
		}
		Sigprocmask(SIG_SETMASK, &prev_mask, NULL);
	}
    /* Process built-in commands */
    else {  
      if (!strcmp(argv[0], "jobs")) {
        display_jobs();
      }
      else if (!strcmp(argv[0], "fg")) {
        do_bgfg(FG, argv[1]);
      }
      else if(!strcmp(argv[0], "bg")) {
        do_bgfg(BG, argv[1]);
      }
    }
    
    return;
}

/* If first arg is a builtin command, run it and return true */
int builtin_command(char **argv) 
{
    if (!strcmp(argv[0], "quit")) /* quit command */
	exit(0);  
    if (!strcmp(argv[0], "&"))    /* Ignore singleton & */
		return 1;
	else if(!strcmp(argv[0], "jobs") || !strcmp(argv[0], "bg")
		  || !strcmp(argv[0], "fg"))
		return 1;
	
    return 0;                     /* Not a builtin command */
}
/* $end eval */

/* $begin parseline */
/* parseline - Parse the command line and build the argv array */
int parseline(char *buf, char **argv) 
{
    char *delim;         /* Points to first space delimiter */
    int argc;            /* Number of args */
    int bg;              /* Background job? */

    buf[strlen(buf)-1] = ' ';  /* Replace trailing '\n' with space */
    while (*buf && (*buf == ' ')) /* Ignore leading spaces */
	buf++;

    /* Build the argv list */
    argc = 0;
    while ((delim = strchr(buf, ' '))) {
	argv[argc++] = buf;
	*delim = '\0';
	buf = delim + 1;
	while (*buf && (*buf == ' ')) /* Ignore spaces */
            buf++;
    }
    argv[argc] = NULL;
    
    if (argc == 0)  /* Ignore blank line */
	return 1;

    /* Should the job run in the background? */
    if ((bg = (*argv[argc-1] == '&')) != 0)
	argv[--argc] = NULL;

    return bg;
}
/* $end parseline */

void display_jobs()
{
	process_entry_t *entry;
	entry = global_list;
	while(entry)
	{
		if (entry->run_status == STOPPED)
			printf("[%d] %d Stopped\t %s", entry->job_id, entry->process_id, entry->cmdline);
		else if (entry->run_status == RUNNING)
			printf("[%d] %d Running\t %s", entry->job_id, entry->process_id, entry->cmdline);
		entry = entry->next;
	}
}

void do_bgfg(int fgbg, char *job_num)
{
	int process;
	process_entry_t *job;
	sigset_t mask, prev_mask; /* Signal masks */
	if (!job_num)
	{
		printf("Please specify job/process num\n");
		return;
	}
	
	if (job_num[0] == '%')
	{
		process = atoi(job_num+1);
		if ((job=find_job(process, JOBID)) == NULL)
		{
			printf("%s: No such process\n", job_num);
			return;
		}
	}
	else
	{
		process = atoi(job_num);
		if ((job=find_job(process, PROCESSID)) == NULL)
		{
			printf("%s: No such process\n", job_num);
			return;
		}
	}
	if (fgbg == BG) {
		printf("[%d] %d %s", job->job_id, job->process_id, job->cmdline);
		kill(job->process_id, SIGCONT);
	}
	else if(fgbg == FG) {
		Sigemptyset(&mask);
		Sigaddset(&mask, SIGCHLD);
		Sigprocmask(SIG_BLOCK, &mask, &prev_mask);
        fg_process = job->process_id;
        kill(job->process_id, SIGCONT);
        global_pid = 0;
        while (!global_pid)
			sigsuspend(&prev_mask);
        Sigprocmask(SIG_SETMASK, &prev_mask, NULL);
		
	}
}

/* Function to add jobs */
int add_job(pid_t pid, char *cmd_line)
{
  //printf("Adding job for pid %d\n", pid);
	process_entry_t *jobs;
	/* Create job entry */
	process_entry_t *new_job = (process_entry_t *)malloc(sizeof(process_entry_t));
	if (!new_job) /* if unable to create new job */
		return 0;
	global_job_id++;
	new_job->job_id = global_job_id;
	new_job->process_id = pid;
	new_job->run_status = RUNNING;
	strcpy(new_job->cmdline, cmd_line);
	new_job->next = NULL;
	/* Triverse to end of list */
	if (global_list == NULL)
		global_list = new_job;
	else
	{
		jobs = global_list;
		while(jobs->next)
			jobs = jobs->next;
		/* Add job to end of list */
		jobs->next = new_job;
		/* return true for sucess */
	}
	return 1;
}

/* Function to delete jobs */
void delete_jobs(pid_t pid)
{
	process_entry_t *jobs, *previous;
	/* if only job in list */
	if (global_list->next == NULL) {
		free(global_list);
		global_list = NULL;
		global_job_id = 0;
		return;
	} 
	previous = jobs = global_list;
	
	while (jobs)
	{
		if (jobs->process_id == pid) { /* we found the job */
			/* First entry in list */
			if (jobs == global_list) {
				global_list = jobs->next;
			}
			else {
				previous->next = jobs->next;
			}
			
			free(jobs);
			return;
		}
		else
		{
			previous = jobs;
			jobs = jobs->next;
		}
	}
}

process_entry_t* find_job(int process, int type) /* Function to find job from global list */
{
	process_entry_t *jobs = global_list;
	while (jobs)
	{
		if (type == JOBID) {
			if (jobs->job_id == process) {
				return jobs;
			}
		}
		else {
			if (jobs->process_id == process) {
				return jobs;
			}
		}
		jobs = jobs->next;
	}
	return NULL;
}

int update_process(pid_t pid, char run_status) /* Function to update run status of a process */
{
	process_entry_t *jobs = global_list;
	while (jobs)
	{
		if (jobs->process_id == pid)
		{
			jobs->run_status = run_status;
			return 1;
		}
		jobs = jobs->next;
	}
	/* Didn't find job by process id, return false */
	return 0;
}
