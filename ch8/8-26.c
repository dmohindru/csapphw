/* Homework Problem 8-26 */
/*Things to implement
 * 1. Built-in commands
 * 	  jobs
 * 	  bg 
 *    fg
 * 	  kill (will need to do it in lab)
 * 2. Way to maintain list of list of jobs (possibly linked list implementation)
 * 3. Handling of Ctrl+C(Ctrl+Z) signals
 * 4. Sending of SIGCONT signal by bg job
 * 5. Sending of SIGCONT signal by fg job
 * 6. Way to start/stop a process
 * 7. Way to restart a process
 * Pointer to solution
 * kill system call to send signal to jobs
 * receving signal with signal system call
 * SIGTSTP - to stop a running process
 * SIGCONT - to restart a process stoped by SIGSTOP
 * waitpid system call to get status of process (running/stoped) ref pg. 780
 * WIFSTOPPED(status) if process is stoped
 * WSTOPSIG(status) to find signal that stopped process
 */
#include "csapp.h"
#define MAXARGS   128
#define FG			0 /* Foreground process */
#define BG			1 /* Background process */
#define JOBID		0 /* Find process by job id */
#define PROCESSID	1 /* Find process by process num */
#define RUNNING		0 /* Process is running */
#define STOPPED		1 /* Process is stopped */
/* Process entry structure */
typedef struct process_entry
{
	unsigned int job_id;     /* Job ID to be generated by program */
	unsigned int process_id; /* Process ID returned by kernel */
	char run_status;	 	 /* Run status of process */
	char cmdline[MAXLINE];	 /* Command line string */
	struct process_entry *next;			 /* Pointer to next entry in linked list */
} process_entry_t;

/* Global variables */
unsigned int global_job_id; /* global variable to record number of job being generated */
process_entry_t *global_list; /* global list to keep track of number of jobs being run */
//pid_t fg_process; 
jmp_buf buf; /* Jump buffer used in setjmp and longjmp */
volatile sig_atomic_t global_pid;

/* Function prototypes */
void eval(char *cmdline);
int parseline(char *buf, char **argv);
int builtin_command(char **argv);
int add_job(pid_t pid, char *cmd_line); /* Function to add job to list */
void delete_jobs(pid_t pid); /* Function to delete job from list */
pid_t find_job(int process, int type); /* Function to find job from global list */
void display_jobs(); /* Function to display jobs */
void do_bgfg(int fgbg, char *job_num); /* Function to process bg and fg command */

/* Handler for SIGCHLD signal */
void handler_sigchld(int sig)
{
	/* This handler is called when
	 * 1. Child is terminated
	 * 2. Child is stopped
	 * 3. Child is continued
	 */
	pid_t pid;
	printf("sigchld handler\n");
	/* check for terminating process */
	while ((pid = waitpid(-1, NULL, WNOHANG)) > 0) {
      //printf("Inside else block of sigchld handler\n");
      printf("terminating process %d\n", pid);
      delete_jobs(pid);
      siglongjmp(buf, 1);
	}
	
	/* check for stopped process */
	while ((pid = waitpid(-1, NULL, WNOHANG|WUNTRACED)) > 0) {
      //printf("Inside else block of sigchld handler\n");
      printf("stopped process %d\n", pid);
      //delete_jobs(pid);
      siglongjmp(buf, 1);
	}
	
	/* check for continued process */
	while ((pid = waitpid(-1, NULL, WNOHANG|WCONTINUED)) > 0) {
      //printf("Inside else block of sigchld handler\n");
      printf("continued process %d\n", pid);
      //delete_jobs(pid);
      siglongjmp(buf, 1);
	}
	
	//siglongjmp(buf, 1);
}

/* Handler for SIGINT signal */
void handler_sigint(int sig)
{
	pid_t pid;
	sigset_t mask, prev_mask; /* Signal masks */
	printf("Inside sigint handler\n");
	//Sigemptyset(&mask);
	//Sigaddset(&mask, SIGCHLD);
	//Sigprocmask(SIG_BLOCK, &mask, &prev_mask);
	while ((pid = waitpid(-1, NULL, WNOHANG|WUNTRACED|WCONTINUED)) > 0) {
      printf("sigint received for process %d\n", pid);
      kill(pid, SIGINT);
      delete_jobs(pid);
	}
	//Sigprocmask(SIG_SETMASK, &prev_mask, NULL);
	siglongjmp(buf, 1);
}
/* Handler for SIGTSTP signal */
void handler_sigtstp(int sig) 
{
  pid_t pid;
  sigset_t mask, prev_mask; /* Signal masks */
  printf("Inside sigtstp handler\n");
  //Sigemptyset(&mask);
  //Sigaddset(&mask, SIGCHLD);
  //Sigprocmask(SIG_BLOCK, &mask, &prev_mask);
  if ((pid = waitpid(-1, NULL, WNOHANG|WUNTRACED)) > 0) {
      printf("sigtstp received for process %d\n", pid);
      kill(pid, SIGTSTP);
      //delete_jobs(pid);
	}
  //Sigprocmask(SIG_SETMASK, &prev_mask, NULL);
  siglongjmp(buf, 1);
}

int main() 
{
    char cmdline[MAXLINE]; /* Command line */
    
    /* Initalize global variables */
    global_job_id = 0;
    global_list = NULL;
   // fg_process = -1;
	
    if (!sigsetjmp(buf, 1)) {
        /*Install signal handlers */
        Signal(SIGINT, handler_sigint);
        Signal(SIGCHLD, handler_sigchld);
        Signal(SIGTSTP, handler_sigtstp);
        //Sio_puts("starting\n");
    }
    while (1) {
      /* Read */
      printf("> ");                   
      Fgets(cmdline, MAXLINE, stdin); 
      if (feof(stdin))
        exit(0);
      /* Evaluate */
      eval(cmdline);
    } 
}
/* $end shellmain */
  
/* $begin eval */
/* eval - Evaluate a command line */
void eval(char *cmdline) 
{
    char *argv[MAXARGS]; /* Argument list execve() */
    char buf[MAXLINE];   /* Holds modified command line */
    int bg;              /* Should the job run in bg or fg? */
    pid_t pid;           /* Process id */
    sigset_t mask, prev_mask; /* Signal masks */
    
    strcpy(buf, cmdline);
    bg = parseline(buf, argv); 
    if (argv[0] == NULL)  
      return;   /* Ignore empty lines */

    if (!builtin_command(argv)) { 
        if ((pid = Fork()) == 0) {   /* Child runs user job */
            if (execve(argv[0], argv, environ) < 0) {
                printf("%s: Command not found.\n", argv[0]);
                exit(0);
            }
            /* else send some kind of signal to parent to notify
             * of successfull execve call
             */
        }
        /* Parent process shellex */
        else { 
          /* Block SIGCHLD here to avoid race condition */
          /* Bug to have add_job her like this */
          if (!add_job(pid, cmdline)) {
            printf("Unable to add job to job list. Exiting....\n");
            exit(0);
          }
        }

      /* Parent waits for foreground job to terminate */
      if (!bg) {
        Sigemptyset(&mask);
        Sigaddset(&mask, SIGCHLD);
        Sigprocmask(SIG_BLOCK, &mask, &prev_mask);
        //fg_process = pid;
        int status;
        // we can block SIGCHLD here 
        if (waitpid(pid, &status, 0) < 0)
          unix_error("waitfg: waitpid error");
          // these two below statement are not getting executed for for ground process
          //fg_process = -1;
		  delete_jobs(pid);
		  Sigprocmask(SIG_SETMASK, &prev_mask, NULL);
        // unblock sigchld here
      }
      else
        printf("[%d] %d %s",global_job_id, pid, cmdline);
    }
    else { /* Process built-in commands */ 
      if (!strcmp(argv[0], "jobs")) {
        display_jobs();
      }
      else if (!strcmp(argv[0], "fg")) {
        do_bgfg(FG, argv[1]);
      }
      else if(!strcmp(argv[0], "bg")) {
        do_bgfg(BG, argv[1]);
      }
    }
    
    return;
}

/* If first arg is a builtin command, run it and return true */
int builtin_command(char **argv) 
{
    if (!strcmp(argv[0], "quit")) /* quit command */
	exit(0);  
    if (!strcmp(argv[0], "&"))    /* Ignore singleton & */
		return 1;
	else if(!strcmp(argv[0], "jobs") || !strcmp(argv[0], "bg")
		  || !strcmp(argv[0], "fg"))
		return 1;
	
    return 0;                     /* Not a builtin command */
}
/* $end eval */

/* $begin parseline */
/* parseline - Parse the command line and build the argv array */
int parseline(char *buf, char **argv) 
{
    char *delim;         /* Points to first space delimiter */
    int argc;            /* Number of args */
    int bg;              /* Background job? */

    buf[strlen(buf)-1] = ' ';  /* Replace trailing '\n' with space */
    while (*buf && (*buf == ' ')) /* Ignore leading spaces */
	buf++;

    /* Build the argv list */
    argc = 0;
    while ((delim = strchr(buf, ' '))) {
	argv[argc++] = buf;
	*delim = '\0';
	buf = delim + 1;
	while (*buf && (*buf == ' ')) /* Ignore spaces */
            buf++;
    }
    argv[argc] = NULL;
    
    if (argc == 0)  /* Ignore blank line */
	return 1;

    /* Should the job run in the background? */
    if ((bg = (*argv[argc-1] == '&')) != 0)
	argv[--argc] = NULL;

    return bg;
}
/* $end parseline */

void display_jobs()
{
	int status, return_val;
	process_entry_t *entry;
	entry = global_list;
	while(entry)
	{
		status = 0;
		if(waitpid(entry->process_id, &status, WUNTRACED|WNOHANG) == -1)
			printf("Error in getting status for process id: %d\n", entry->process_id);
		//return_val = WIFSTOPPED(status);
		//printf("return_val: %d\n", return_val);
		if (WIFSTOPPED(status))
			printf("[%d] %d Stopped\t %s", entry->job_id, entry->process_id, entry->cmdline);
		else
			printf("[%d] %d Running\t %s", entry->job_id, entry->process_id, entry->cmdline);
				
		
		entry = entry->next;
	}
	//printf("Displaying jobs\n");
}

void do_bgfg(int fgbg, char *job_num)
{
	int process, status;;
	pid_t pid;
	if (!job_num)
	{
		printf("Please specify job/process num\n");
		return;
	}
	
	if (job_num[0] == '%')
	{
		process = atoi(job_num+1);
		//printf("Finding by job id %d\n", process);
		if ((pid=find_job(process, JOBID)) == 0)
		{
			printf("%s: No such process\n", job_num);
			return;
		}
		/*else
		{
			printf("Found job id %d with process id %d\n", process, pid);
			if (fgbg == BG)
		}*/
	}
	else
	{
		process = atoi(job_num);
		//printf("Finding by process id %d\n", process);
		if ((pid=find_job(process, PROCESSID)) == 0)
		{
			printf("%s: No such process\n", job_num);
			return;
		}
		/*else
		{
			printf("Found process id %d\n", pid);
		}*/
	}
	if (fgbg == BG) {
		printf("Restarting job in background with pid=%d\n", pid);
		printf("Some background signal handling\n");
		kill(pid, SIGCONT);
	}
	else if(fgbg == FG) {
		printf("Restarting job in foreground with pid=%d\n", pid);
		printf("Some foreground signal handling\n");
        kill(pid, SIGCONT);
        if (waitpid(pid, &status, 0) < 0)
          unix_error("waitfg: waitpid error");
		
	}
}

/* Function to add jobs */
int add_job(pid_t pid, char *cmd_line)
{
  printf("Adding job for pid %d\n", pid);
	process_entry_t *jobs;
	/* Create job entry */
	process_entry_t *new_job = (process_entry_t *)malloc(sizeof(process_entry_t));
	if (!new_job) /* if unable to create new job */
		return 0;
	global_job_id++;
	new_job->job_id = global_job_id;
	new_job->process_id = pid;
	new_job->run_status = RUNNING;
	//strcpy(new_job->run_status, "testing");
	strcpy(new_job->cmdline, cmd_line);
	new_job->next = NULL;
	/* Triverse to end of list */
	if (global_list == NULL)
		global_list = new_job;
	else
	{
		jobs = global_list;
		while(jobs->next)
			jobs = jobs->next;
		/* Add job to end of list */
		jobs->next = new_job;
		/* return true for sucess */
	}
	return 1;
}

/* Function to delete jobs */
void delete_jobs(pid_t pid)
{
  printf("Deleting job for pid %d\n", pid);
	process_entry_t *jobs, *previous;
	/* if only job in list */
	if (global_list->next == NULL) {
		free(global_list);
		global_list = NULL;
		global_job_id = 0;
		return;
	} 
	previous = jobs = global_list;
	
	while (jobs)
	{
		if (jobs->process_id == pid) { /* we found the job */
			/* First entry in list */
			if (jobs == global_list) {
				global_list = jobs->next;
			}
			else {
				previous->next = jobs->next;
			}
			
			free(jobs);
			return;
		}
		else
		{
			previous = jobs;
			jobs = jobs->next;
		}
	}
}

pid_t find_job(int process, int type) /* Function to find job from global list */
{
	pid_t pid = 0;
	process_entry_t *jobs = global_list;
	while (jobs)
	{
		if (type == JOBID) {
			if (jobs->job_id == process) {
				pid = jobs->process_id;
				break;
			}
		}
		else {
			if (jobs->process_id == process) {
				pid = jobs->process_id;
				break;
			}
		}
		jobs = jobs->next;
	}
	return pid;
}
